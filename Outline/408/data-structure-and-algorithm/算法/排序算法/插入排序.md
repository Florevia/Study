# 插入排序 (Insertion Sort)

类似于整理扑克牌：从左到右依次取出每张牌，插入到左边已排序部分的正确位置。

## 算法步骤

1. 把数组分成两部分：左边是**已排序**，右边是**未排序**
2. 初始时，第一个元素自成已排序部分
3. 从第二个元素开始，依次取出未排序部分的第一个元素
4. 在已排序部分**从右向左**扫描，找到合适位置插入
5. 重复步骤 3-4，直到所有元素都被插入到已排序部分

## JavaScript 实现

```js
function insertionSort(arr) {
  // 从第二个元素开始（索引1），第一个元素默认已排序
  for (let i = 1; i < arr.length; i++) {
    const current = arr[i]; // 当前要插入的元素
    let j = i - 1; // 已排序部分的最后一个索引

    // 从右向左扫描已排序部分，找到插入位置
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j]; // 元素后移
      j--;
    }

    // 插入到空出来的位置
    arr[j + 1] = current;
  }

  return arr;
}

console.log(insertionSort([5, 3, 4, 1, 2])); // [1, 2, 3, 4, 5]
```

## 复杂度分析

- 时间复杂度：

| 情况     | 时间复杂度 | 说明                            |
| -------- | ---------- | ------------------------------- |
| 最好情况 | O(n)       | 数组已经有序，每次只需比较 1 次 |
| 最坏情况 | O(n²)      | 数组完全逆序                    |
| 平均情况 | O(n²)      | -                               |

- **空间复杂度**: O(1) - 原地排序

## 特点

## 使用场景

1. **小规模数据排序**（n < 50）
2. **数据基本有序**的情况
3. 作为其他高级排序算法（如快速排序、归并排序）的子过程，处理小规模子数组

## 与其他排序对比

| 排序算法 | 平均时间复杂度 | 是否稳定 | 适用场景         |
| -------- | -------------- | -------- | ---------------- |
| 冒泡排序 | O(n²)          | ✅       | 教学目的         |
| 选择排序 | O(n²)          | ❌       | 简单场景         |
| 插入排序 | O(n²)          | ✅       | 小规模/基本有序  |
| 快速排序 | O(n log n)     | ❌       | 大规模通用       |
| 归并排序 | O(n log n)     | ✅       | 需要稳定的大规模 |
