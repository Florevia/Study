# 选择排序 (Selection Sort)

每次从未排序部分中**选择最小（或最大）的元素**，放到已排序部分的末尾。

## 算法步骤

1. 把数组分成两部分：左边是**已排序**，右边是**未排序**
2. 初始时，已排序部分为空
3. 遍历未排序部分，找到**最小元素**的索引
4. 将最小元素与未排序部分的**第一个元素**交换
5. 已排序部分扩大一位，重复步骤 3-4，直到整个数组有序

## 图示

```
初始:   [64, 25, 12, 22, 11]
         ^未排序

第1轮:  找到最小值11，与64交换
        [11, 25, 12, 22, 64]
         ✓   ^未排序

第2轮:  找到最小值12，与25交换
        [11, 12, 25, 22, 64]
         ✓   ✓   ^未排序

第3轮:  找到最小值22，与25交换
        [11, 12, 22, 25, 64]
         ✓   ✓   ✓   ^未排序

第4轮:  找到最小值25，无需交换
        [11, 12, 22, 25, 64]
         ✓   ✓   ✓   ✓   ✓
```

## JavaScript 实现

```js
Array.prototype.selectionSort = function () {
  // 遍历数组，i 是已排序部分的边界
  for (let i = 0; i < this.length - 1; i++) {
    let minIndex = i; // 假设当前位置是最小值
    // 在未排序部分找最小值
    for (let j = i + 1; j < this.length; j++) {
      // 如果最小值不在当前位置，交换
      if (this[j] < this[minIndex]) {
        minIndex = j;
      }
    }
    // 交换
    [this[i], this[minIndex]] = [this[minIndex], this[i]];
  }
  return this;
};

console.log([64, 25, 12, 22, 11].selectionSort());
```

## 复杂度分析

| 情况     | 时间复杂度 | 说明                       |
| -------- | ---------- | -------------------------- |
| 最好情况 | O(n²)      | 即使数组有序，仍需完整遍历 |
| 最坏情况 | O(n²)      | -                          |
| 平均情况 | O(n²)      | -                          |

- **空间复杂度**: O(1) - 原地排序

## 特点

### 优点

- ✅ 实现简单，容易理解
- ✅ 原地排序，不需要额外空间
- ✅ **交换次数少**：最多 n-1 次交换（每轮最多 1 次）

### 缺点

- ❌ 时间复杂度始终是 O(n²)，即使数组已经有序
- ❌ 不稳定排序

## 与插入排序对比

| 特性     | 选择排序         | 插入排序              |
| -------- | ---------------- | --------------------- |
| 核心思想 | 每次选最小放前面 | 每次插入到正确位置    |
| 稳定性   | ❌ 不稳定        | ✅ 稳定               |
| 最好情况 | O(n²)            | O(n) - 对有序数组友好 |
| 交换次数 | O(n)             | O(n²)                 |
| 适用场景 | 交换成本高时     | 数据基本有序时        |
