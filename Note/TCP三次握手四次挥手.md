
## 一、三次握手（建立连接）

### （1）要解决什么问题？

建立连接本质上要做到两件事：

1. **双方确认彼此“能收能发”**（网络路径 OK）。
2. **同步初始序列号 ISN**（Sequence Number），让后续的可靠传输（确认/重传/乱序重排）能工作。

> 序列号是 TCP “可靠性”的核心：每一段数据都有序号，接收方靠 ACK 告诉发送方“我已经收到了哪儿”。

---

### （2）三次握手每一步做什么？

假设客户端是 C，服务端是 S：

#### 第 1 次：C → S（SYN）

* C 发送一个报文段：`SYN=1, seq=x`
* 意味着：**“我想建立连接，我的初始序列号是 x。”**
* C 进入状态：`SYN_SENT`

#### 第 2 次：S → C（SYN + ACK）

* S 收到后回复：`SYN=1, ACK=1, seq=y, ack=x+1`
* 意味着：

  * **“我同意建立连接，我的初始序列号是 y。”**
  * **“并且我确认收到了你的 SYN（你从 x 开始），你下一次该发 x+1。”**
* S 进入状态：`SYN_RECEIVED`

#### 第 3 次：C → S（ACK）

* C 再发：`ACK=1, seq=x+1, ack=y+1`
* 意味着：**“我确认收到了你的 SYN，你下一次从 y+1 开始发。”**
* C 进入状态：`ESTABLISHED`
* S 收到这个 ACK 后进入：`ESTABLISHED`

✅ 连接建立完成。

---

### （3）为什么不是两次握手？

如果只有两次（SYN -> SYN+ACK），会出现经典问题：

* **服务端无法确认“客户端是否真的收到了我的 SYN+ACK”。**
* 可能导致 **半连接/资源浪费** 或 **旧的重复 SYN 导致错误建立连接**（历史报文段在网络中延迟到达）。

第三次 ACK 的作用就是：**让服务端确认客户端确实收到了服务端的初始序列号 y，并且双方的收发能力都确认完成。**

---

### （4）握手期间的关键点（面试常问）

* SYN 会消耗一个序列号，所以 ack 是 `x+1`、`y+1`。
* 服务端在 `SYN_RECEIVED` 会维护一个 **半连接队列**（backlog），这也是 SYN Flood 攻击的利用点。
* 可选优化：**TCP Fast Open**（不是所有场景都启用）。

---

## 二、四次挥手（断开连接）

### （1）为什么挥手要四次？

因为 TCP 连接是 **全双工**：两条方向独立的数据流。

断开连接时，通常需要分别关闭：

* A 不再发（A→B 的发送方向关闭）
* B 不再发（B→A 的发送方向关闭）

因此，常见情况是：

* **A 先发 FIN 表示“我这边不发了”**
* B 可能还有数据要发完，所以 B 先 ACK，再等自己也发完后再 FIN
* A 再 ACK

这就变成 **FIN/ACK/FIN/ACK**（看起来是四次）。

---

### （2）四次挥手流程（以客户端主动关闭为例）

假设客户端 C 主动关闭，服务端 S 被动关闭：

#### 第 1 次：C → S（FIN）

* C 发送：`FIN=1, seq=u`
* 意味着：**“我这边发完了，以后不再发送数据。”**
* C 状态：`FIN_WAIT_1`

#### 第 2 次：S → C（ACK）

* S 回复：`ACK=1, ack=u+1`
* 意味着：**“收到你要关闭发送方向的请求。”**
* S 状态：`CLOSE_WAIT`
* C 收到 ACK 后状态：`FIN_WAIT_2`

> 注意：此时 **连接还没完全断**
> 只是 **C 不能再发**，但 **C 仍然可以收**，因为 S 可能还有数据没发完。

#### 第 3 次：S → C（FIN）

* S 等自己数据发完后，再发：`FIN=1, seq=v`
* 意味着：**“我也发完了，我这边也要关闭发送方向。”**
* S 状态：`LAST_ACK`

#### 第 4 次：C → S（ACK）

* C 回复：`ACK=1, ack=v+1`
* C 状态：`TIME_WAIT`
* S 收到 ACK 后：`CLOSED`

---

### （3）为什么会有 TIME_WAIT（非常高频）

C 在最后发完 ACK 后进入 `TIME_WAIT`，并等待 **2MSL**（最大报文生存时间的两倍）。

主要两个目的：

1. **确保最后一个 ACK 能到达对方**

   - 如果 ACK 丢了，S 会重发 FIN
   - C 在 TIME_WAIT 期间还能再回 ACK，保证 S 能正常关闭

2. **让本连接的“旧报文段”在网络中自然消失**

   - 避免旧连接的延迟包，跑到新连接里造成混乱（尤其是同一四元组：源 IP/源端口/目的 IP/目的端口）

3. 谁进入 TIME_WAIT？
    - 通常是 **主动关闭连接的一方**。

---

## 三、一个超级直观的总结（口诀版）

* **三次握手：**
    - 我想连（SYN）
    - 我同意 + 我也想连（SYN+ACK）
    - 我确认（ACK）

* **四次挥手：**
    - 我不发了（FIN）
    - 收到，你先别发了（ACK）
    - 我也不发了（FIN）
    - 收到，那就都关了（ACK）
  主动方再等一会儿（TIME_WAIT）

---

## 四、你最该会的几个面试追问

1. **为什么建立 3 次，关闭 4 次？**

-  建立：服务端需要确认客户端确实收到了自己的 SYN（第三次 ACK）。
-  关闭：全双工，两边关闭发送方向可能不同时发生，所以通常分开两次 FIN。

2. **TIME_WAIT 过多会怎样？怎么缓解？**

-  现象：端口占用、连接数上不去（尤其高并发短连接）。
-  缓解方向：连接复用（keep-alive）、合理的负载设计、内核参数调优（但要谨慎，涉及可靠性）。

3. **CLOSE_WAIT 多说明什么？**

- 通常说明：对端已经 FIN 了（你 ACK 了），但你自己的应用层没有 close socket，导致一直卡在 CLOSE_WAIT。

