# 原生 DOM 实现输入框实时搜索

## 思路

```
┌────────────────┐
│  用户输入 "xxx"  │
└────────┬───────┘
         ↓
┌────────────────┐
│  触发 input 事件│
└────────┬───────┘
         ↓
┌────────────────┐
│  防抖等待 300ms │  ← 如果继续输入，重新计时
└────────┬───────┘
         ↓
┌────────────────┐
│  filterData()  │  ← 过滤匹配项
└────────┬───────┘
         ↓
┌────────────────┐
│ renderResults()│  ← 更新 DOM
└────────────────┘
```

html 结构

```html
<input type="text" id="search-input" placeholder="搜索..." />
<ul id="result-list"></ul>
```

数据源

```js
const data = [
  { id: 1, name: "苹果" },
  { id: 2, name: "香蕉" },
  { id: 3, name: "橙子" },
  // ...
];
```

第一步： 输入监听事件 + 过滤

```js
const input = document.getElementById("search-input");
input.addEventListener("input", (e) => {
  const keyword = e.target.value;
  filterData(keyword);
});

function filterData(keyword) {
  const filteredData = data.filter(item) => {
    return item.name.includes(keyword);
  }}
```

第二步：渲染搜索结果

```js
function renderResults(data) {
  const list = document.getElementById("result-list");

  // 清空原来结果
  list.innerHTML = "";

  list.innerHTML = data
    .map((item) => {
      return `<li>${item.name}</li>`;
    })
    .join("");
}
renderResults(filteredData);
```

高级处理： 防抖优化

```js
function debounce(fn, delay) {
  let timer;
  return function (...arg) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arg);
      // 绑定fn的this为调用debounce的上下文，否则this指向window，arg是一个数组
    }, delay);
  };
}

const handleSearch = debounce(filterData, 300); // 返回一个函数

input.addEventListener("input", (e) => {
  const keyword = e.target.value;
  handleSearch(keyword);
});
```

处理空输入

```js
const keyword = e.target.value.trim();
if (!keyword) {
  renderResults([]);
  return;
}

filterData(keyword);
```

第三步： 高亮处理

```js
function highlightMatch(text, keyword) {
  const regex = new RegExp([(${keyword})]);
  return text.replace(regex, "<span class='highlight'>$1</span>");
}

// 使用
li.innerHTML = highlightMatch(item.name, keyword);
```

# SPA 框架中的实现

数据源：路由配置

```js
// router/index.js
const routes = [
  {
    path: '/user',
    name: 'user',
    meta: { title: '用户管理', icon: 'user' },
    children: [
      {
        path: 'manage',
        name: 'EmployeeManage',
        meta: { title: '员工管理' }
      },
      {
        path: 'role',
        name: 'RoleList',
        meta: { title: '角色列表' }
      }
    ]
  },
  {
    path: '/article',
    name: 'article',
    meta: { title: '文章管理' },
    children: [...]
  }
]
```

第一步： 将路由表转化成数据源

```
┌─────────────────────────┐
│  路由配置（routes）       │
└─────────┬───────────────┘
          ↓
┌─────────────────────────┐
│  generateSearchData()   │  ← 扁平化 + 提取 title/path
└─────────┬───────────────┘
          ↓
┌─────────────────────────┐
│  searchData（数组）      │  ← 可搜索的数据源
└─────────┬───────────────┘
          ↓
┌─────────────────────────┐
│  用户输入关键词           │
└─────────┬───────────────┘
          ↓
┌─────────────────────────┐
│  filterRoutes()         │  ← 过滤匹配项
└─────────┬───────────────┘
          ↓
┌─────────────────────────┐
│  显示搜索结果            │
└─────────┬───────────────┘
          ↓
┌─────────────────────────┐
│  用户点击 → router.push │  ← 跳转页面
└─────────────────────────┘

```
